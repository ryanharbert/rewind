<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Bitset ECS Performance Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            white-space: pre-wrap;
        }
        #output {
            background-color: #2d2d2d;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        button {
            margin-bottom: 20px;
            padding: 10px 20px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #005a9e;
        }
    </style>
</head>
<body>
    <h1>JavaScript Bitset ECS Performance Test (Web)</h1>
    <button onclick="runTest()">Run Performance Test</button>
    <div id="output"></div>

    <script>
        // Inline the bitset-ecs.js code here since we can't use require in browser
        const INVALID_ENTITY = 0xFFFFFFFF;

        // Entity limits (same as Zig)
        const EntityLimit = {
            tiny: 64,
            small: 256,
            medium: 512,
            large: 1024,
            huge: 2048,
            massive: 4096
        };

        // BitSet implementation for JavaScript
        class BitSet {
            constructor(size) {
                this.size = size;
                this.words = new Uint32Array(Math.ceil(size / 32));
            }

            set(index) {
                if (index >= this.size) return;
                const wordIndex = Math.floor(index / 32);
                const bitIndex = index % 32;
                this.words[wordIndex] |= (1 << bitIndex);
            }

            unset(index) {
                if (index >= this.size) return;
                const wordIndex = Math.floor(index / 32);
                const bitIndex = index % 32;
                this.words[wordIndex] &= ~(1 << bitIndex);
            }

            isSet(index) {
                if (index >= this.size) return false;
                const wordIndex = Math.floor(index / 32);
                const bitIndex = index % 32;
                return (this.words[wordIndex] & (1 << bitIndex)) !== 0;
            }

            clear() {
                this.words.fill(0);
            }

            // Intersect with another bitset (for queries)
            intersectWith(other) {
                const result = new BitSet(this.size);
                for (let i = 0; i < this.words.length; i++) {
                    result.words[i] = this.words[i] & other.words[i];
                }
                return result;
            }

            // Iterator for set bits
            *iterator() {
                for (let wordIndex = 0; wordIndex < this.words.length; wordIndex++) {
                    let word = this.words[wordIndex];
                    if (word === 0) continue;
                    
                    let baseIndex = wordIndex * 32;
                    while (word !== 0) {
                        // Find the index of the least significant set bit
                        const bitIndex = Math.clz32(word & -word) ^ 31;
                        yield baseIndex + bitIndex;
                        // Clear the least significant set bit
                        word &= word - 1;
                    }
                }
            }

            count() {
                let count = 0;
                for (const word of this.words) {
                    // Brian Kernighan's algorithm for counting set bits
                    let w = word;
                    while (w) {
                        w &= w - 1;
                        count++;
                    }
                }
                return count;
            }

            clone() {
                const result = new BitSet(this.size);
                result.words.set(this.words);
                return result;
            }
        }

        // Component Storage
        class ComponentStorage {
            constructor(maxEntities) {
                this.dense = [];
                this.entityBitset = new BitSet(maxEntities);
                this.entityToIndex = new Uint32Array(maxEntities);
                this.indexToEntity = [];
            }

            add(entity, component) {
                if (this.entityBitset.isSet(entity)) return; // Already exists
                
                const index = this.dense.length;
                this.dense.push(component);
                this.indexToEntity.push(entity);
                this.entityToIndex[entity] = index;
                this.entityBitset.set(entity);
            }

            get(entity) {
                if (!this.entityBitset.isSet(entity)) return null;
                const index = this.entityToIndex[entity];
                return this.dense[index];
            }

            has(entity) {
                return this.entityBitset.isSet(entity);
            }

            remove(entity) {
                if (!this.entityBitset.isSet(entity)) return false;
                
                const index = this.entityToIndex[entity];
                const lastIndex = this.dense.length - 1;
                
                // Swap with last element for O(1) removal
                if (index !== lastIndex) {
                    const lastEntity = this.indexToEntity[lastIndex];
                    this.dense[index] = this.dense[lastIndex];
                    this.indexToEntity[index] = lastEntity;
                    this.entityToIndex[lastEntity] = index;
                }
                
                this.dense.pop();
                this.indexToEntity.pop();
                this.entityBitset.unset(entity);
                
                return true;
            }

            count() {
                return this.dense.length;
            }
        }

        // ECS Implementation
        class ECS {
            constructor(config) {
                this.componentTypes = config.components;
                this.maxEntities = config.maxEntities || EntityLimit.medium;
                
                // Component type to index mapping
                this.componentIndices = new Map();
                this.componentTypes.forEach((type, index) => {
                    this.componentIndices.set(type, index);
                });
                
                // Initialize frame state
                this.frameState = {
                    storages: this.componentTypes.map(() => new ComponentStorage(this.maxEntities)),
                    activeEntities: new BitSet(this.maxEntities),
                    nextEntity: 0,
                    entityCount: 0
                };
                
                // Frame data
                this.currentFrame = {
                    state: this.frameState,
                    input: {},
                    deltaTime: 0,
                    time: 0,
                    frameNumber: 0
                };
            }

            createEntity() {
                let entity = this.frameState.nextEntity;
                while (entity < this.maxEntities && this.frameState.activeEntities.isSet(entity)) {
                    entity++;
                }
                
                if (entity >= this.maxEntities) {
                    throw new Error(`Entity limit exceeded: ${this.maxEntities}`);
                }
                
                this.frameState.activeEntities.set(entity);
                this.frameState.entityCount++;
                this.frameState.nextEntity = entity + 1;
                
                return entity;
            }

            destroyEntity(entity) {
                if (!this.frameState.activeEntities.isSet(entity)) return;
                
                // Remove from all component storages
                for (const storage of this.frameState.storages) {
                    storage.remove(entity);
                }
                
                this.frameState.activeEntities.unset(entity);
                this.frameState.entityCount--;
            }

            addComponent(entity, componentType, componentData) {
                if (!this.frameState.activeEntities.isSet(entity)) {
                    throw new Error(`Entity ${entity} does not exist`);
                }
                
                const storageIndex = this.componentIndices.get(componentType);
                if (storageIndex === undefined) {
                    throw new Error(`Component type not registered`);
                }
                
                this.frameState.storages[storageIndex].add(entity, componentData);
            }

            getComponent(entity, componentType) {
                const storageIndex = this.componentIndices.get(componentType);
                if (storageIndex === undefined) return null;
                
                return this.frameState.storages[storageIndex].get(entity);
            }

            hasComponent(entity, componentType) {
                const storageIndex = this.componentIndices.get(componentType);
                if (storageIndex === undefined) return false;
                
                return this.frameState.storages[storageIndex].has(entity);
            }

            removeComponent(entity, componentType) {
                const storageIndex = this.componentIndices.get(componentType);
                if (storageIndex === undefined) return false;
                
                return this.frameState.storages[storageIndex].remove(entity);
            }

            query(componentTypes) {
                // Start with active entities
                let resultEntities = this.frameState.activeEntities.clone();
                
                // Intersect with required component bitsets
                for (const componentType of componentTypes) {
                    const storageIndex = this.componentIndices.get(componentType);
                    if (storageIndex === undefined) {
                        throw new Error(`Component type not registered`);
                    }
                    const componentBitset = this.frameState.storages[storageIndex].entityBitset;
                    resultEntities = resultEntities.intersectWith(componentBitset);
                }
                
                // Return query result object
                const iterator = resultEntities.iterator();
                return {
                    next: () => {
                        const { value, done } = iterator.next();
                        if (done) return null;
                        
                        return {
                            entity: value,
                            get: (componentType) => this.getComponent(value, componentType)
                        };
                    },
                    count: () => resultEntities.count(),
                    reset: () => {
                        // Recreate iterator
                        iterator = resultEntities.iterator();
                    }
                };
            }

            update(input, deltaTime, time) {
                this.currentFrame.input = input;
                this.currentFrame.deltaTime = deltaTime;
                this.currentFrame.time = time;
                this.currentFrame.frameNumber++;
            }

            getEntityCount() {
                return this.frameState.entityCount;
            }
        }

        // Test code
        const Transform = Symbol('Transform');
        const Velocity = Symbol('Velocity');
        const Health = Symbol('Health');

        function updateTransformSystem(ecs) {
            const query = ecs.query([Transform, Velocity]);
            
            let result;
            while ((result = query.next()) !== null) {
                const transform = result.get(Transform);
                const velocity = result.get(Velocity);
                
                // Update position
                transform.x += velocity.dx * ecs.currentFrame.deltaTime;
                transform.y += velocity.dy * ecs.currentFrame.deltaTime;
                transform.rotation += velocity.angular * ecs.currentFrame.deltaTime;
                
                // Keep rotation in bounds
                if (transform.rotation > 360.0) transform.rotation -= 360.0;
                if (transform.rotation < 0.0) transform.rotation += 360.0;
            }
        }

        function damageSystem(ecs) {
            const query = ecs.query([Health]);
            
            let result;
            while ((result = query.next()) !== null) {
                const health = result.get(Health);
                health.current -= 1;
                if (health.current < 0) health.current = health.max;
            }
        }

        function log(message) {
            const output = document.getElementById('output');
            output.textContent += message + '\n';
        }

        function runTest() {
            const output = document.getElementById('output');
            output.textContent = '';
            
            log('=== JavaScript Bitset ECS Performance Test (Web) ===');
            log('Testing with transform updates and damage system\n');
            
            // Test different entity counts (matching Zig test)
            const entityCounts = [100, 250, 500, 750, 1000];
            const frameCount = 10000; // Number of frames to simulate
            
            // Run tests asynchronously to avoid blocking UI
            let currentTest = 0;
            
            function runNextTest() {
                if (currentTest >= entityCounts.length) {
                    log('\n=== End of JavaScript Performance Test ===');
                    return;
                }
                
                const entityCount = entityCounts[currentTest];
                log(`\n--- Testing ${entityCount} entities for ${frameCount} frames ---`);
                
                // Initialize ECS
                const ecs = new ECS({
                    components: [Transform, Velocity, Health],
                    maxEntities: EntityLimit.large // 1024 entities
                });
                
                const setupStart = performance.now();
                
                // Create entities
                for (let i = 0; i < entityCount; i++) {
                    const entity = ecs.createEntity();
                    
                    // All entities get transform
                    ecs.addComponent(entity, Transform, {
                        x: i % 100,
                        y: Math.floor(i / 100),
                        rotation: 0.0
                    });
                    
                    // 60% get velocity (moving entities)
                    if (i % 5 < 3) {
                        ecs.addComponent(entity, Velocity, {
                            dx: ((i % 10) - 5) * 10.0,
                            dy: ((i % 7) - 3) * 10.0,
                            angular: i % 360
                        });
                    }
                    
                    // 40% get health
                    if (i % 5 < 2) {
                        ecs.addComponent(entity, Health, {
                            current: 100,
                            max: 100
                        });
                    }
                }
                
                const setupTime = performance.now() - setupStart;
                
                // Warm up
                for (let i = 0; i < 100; i++) {
                    ecs.update({ deltaTime: 0.016 }, 0.016, 0.0);
                    updateTransformSystem(ecs);
                    damageSystem(ecs);
                }
                
                // Benchmark
                const benchStart = performance.now();
                
                for (let frameNum = 0; frameNum < frameCount; frameNum++) {
                    ecs.update({ deltaTime: 0.016 }, 0.016, frameNum * 0.016);
                    updateTransformSystem(ecs);
                    damageSystem(ecs);
                }
                
                const benchTime = performance.now() - benchStart;
                const avgFrameTime = benchTime / frameCount;
                
                // Count entities with each component for verification
                const transformCount = ecs.query([Transform]).count();
                const velocityCount = ecs.query([Velocity]).count();
                const healthCount = ecs.query([Health]).count();
                
                log(`Setup time: ${setupTime.toFixed(2)}ms`);
                log(`Total benchmark time: ${benchTime.toFixed(2)}ms`);
                log(`Average frame time: ${avgFrameTime.toFixed(3)}ms`);
                log(`FPS: ${(1000.0 / avgFrameTime).toFixed(1)}`);
                log(`Entities - Transform: ${transformCount}, Velocity: ${velocityCount}, Health: ${healthCount}`);
                
                currentTest++;
                setTimeout(runNextTest, 100); // Small delay to let UI update
            }
            
            runNextTest();
        }
    </script>
</body>
</html>