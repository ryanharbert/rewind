const sg = @import("sokol").gfx;

//
//    #version:1# (machine generated, don't edit!)
//
//    Generated by sokol-shdc (https://github.com/floooh/sokol-tools)
//
//    Shader program: 'sprite':
//        Get shader desc: shd.spriteShaderDesc(sg.queryBackend());
//        Vertex Shader: sprite_vs
//        Fragment Shader: sprite_fs
//        Attributes:
//            ATTR_sprite_vs_a_pos => 0
//            ATTR_sprite_vs_a_inst_pos_size => 1
//            ATTR_sprite_vs_a_inst_color => 2
//
pub const ATTR_sprite_vs_a_pos = 0;
pub const ATTR_sprite_vs_a_inst_pos_size = 1;
pub const ATTR_sprite_vs_a_inst_color = 2;

pub const SLOT_vs_params = 0;
pub const SLOT_u_tex = 0;

pub fn spriteShaderDesc(backend: sg.Backend) sg.ShaderDesc {
    var desc: sg.ShaderDesc = .{};
    desc.label = "sprite_shader";
    switch (backend) {
        .D3D11 => {
            desc.attrs[0] = .{ .hlsl_sem_name = "TEXCOORD", .hlsl_sem_index = 0 };
            desc.attrs[1] = .{ .hlsl_sem_name = "TEXCOORD", .hlsl_sem_index = 1 };
            desc.attrs[2] = .{ .hlsl_sem_name = "TEXCOORD", .hlsl_sem_index = 2 };
            desc.vertex_func = .{
                .source = 
                    \\cbuffer vs_params : register(b0) {
                    \\  float4x4 u_projection;
                    \\};
                    \\struct vs_in {
                    \\  float2 a_pos : TEXCOORD0;
                    \\  float4 a_inst_pos_size : TEXCOORD1;
                    \\  float4 a_inst_color : TEXCOORD2;
                    \\  uint inst_id : SV_InstanceID;
                    \\};
                    \\struct vs_out {
                    \\  float2 uv : TEXCOORD0;
                    \\  float4 color : TEXCOORD1;
                    \\  float4 pos : SV_Position;
                    \\};
                    \\vs_out main(vs_in inp) {
                    \\  vs_out outp;
                    \\  float2 pos = inp.a_inst_pos_size.xy + inp.a_pos * inp.a_inst_pos_size.zw;
                    \\  outp.pos = mul(u_projection, float4(pos, 0.0, 1.0));
                    \\  outp.uv = inp.a_pos;
                    \\  outp.color = inp.a_inst_color;
                    \\  return outp;
                    \\}
                ,
                .d3d11_target = "vs_5_0",
                .entry = "main",
            };
            desc.fragment_func = .{
                .source = 
                    \\Texture2D<float4> u_tex : register(t0);
                    \\sampler u_smp : register(s0);
                    \\
                    \\float4 main(float2 uv : TEXCOORD0, float4 color : TEXCOORD1) : SV_Target0 {
                    \\  return u_tex.Sample(u_smp, uv) * color;
                    \\}
                ,
                .d3d11_target = "ps_5_0",
                .entry = "main",
            };
        },
        .METAL_MACOS, .METAL_IOS, .METAL_SIMULATOR => {
            desc.vertex_func = .{
                .source = 
                    \\#include <metal_stdlib>
                    \\using namespace metal;
                    \\struct vs_params {
                    \\  float4x4 u_projection;
                    \\};
                    \\struct vs_in {
                    \\  float2 a_pos [[attribute(0)]];
                    \\  float4 a_inst_pos_size [[attribute(1)]];
                    \\  float4 a_inst_color [[attribute(2)]];
                    \\};
                    \\struct vs_out {
                    \\  float2 uv;
                    \\  float4 color;
                    \\  float4 pos [[position]];
                    \\};
                    \\vertex vs_out main0(vs_in inp [[stage_in]], constant vs_params& params [[buffer(0)]], uint inst_id [[instance_id]]) {
                    \\  vs_out outp;
                    \\  float2 pos = inp.a_inst_pos_size.xy + inp.a_pos * inp.a_inst_pos_size.zw;
                    \\  outp.pos = params.u_projection * float4(pos, 0.0, 1.0);
                    \\  outp.uv = inp.a_pos;
                    \\  outp.color = inp.a_inst_color;
                    \\  return outp;
                    \\}
                ,
                .entry = "main0",
            };
            desc.fragment_func = .{
                .source = 
                    \\#include <metal_stdlib>
                    \\using namespace metal;
                    \\struct fs_in {
                    \\  float2 uv;
                    \\  float4 color;
                    \\};
                    \\fragment float4 main0(fs_in inp [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_smp [[sampler(0)]]) {
                    \\  return u_tex.sample(u_smp, inp.uv) * inp.color;
                    \\}
                ,
                .entry = "main0",
            };
        },
        .GLCORE => {
            desc.attrs[0] = .{ .glsl_name = "a_pos" };
            desc.attrs[1] = .{ .glsl_name = "a_inst_pos_size" };
            desc.attrs[2] = .{ .glsl_name = "a_inst_color" };
            desc.vertex_func = .{
                .source = 
                    \\#version 330
                    \\uniform mat4 u_projection;
                    \\layout(location = 0) in vec2 a_pos;
                    \\layout(location = 1) in vec4 a_inst_pos_size;
                    \\layout(location = 2) in vec4 a_inst_color;
                    \\out vec2 uv;
                    \\out vec4 color;
                    \\void main() {
                    \\  vec2 pos = a_inst_pos_size.xy + a_pos * a_inst_pos_size.zw;
                    \\  gl_Position = u_projection * vec4(pos, 0.0, 1.0);
                    \\  uv = a_pos;
                    \\  color = a_inst_color;
                    \\}
                ,
            };
            desc.fragment_func = .{
                .source = 
                    \\#version 330
                    \\uniform sampler2D u_tex;
                    \\in vec2 uv;
                    \\in vec4 color;
                    \\out vec4 frag_color;
                    \\void main() {
                    \\  frag_color = texture(u_tex, uv) * color;
                    \\}
                ,
            };
        },
        .GLES3 => {
            desc.attrs[0] = .{ .glsl_name = "a_pos" };
            desc.attrs[1] = .{ .glsl_name = "a_inst_pos_size" };
            desc.attrs[2] = .{ .glsl_name = "a_inst_color" };
            desc.vertex_func = .{
                .source = 
                    \\#version 300 es
                    \\uniform mat4 u_projection;
                    \\layout(location = 0) in vec2 a_pos;
                    \\layout(location = 1) in vec4 a_inst_pos_size;
                    \\layout(location = 2) in vec4 a_inst_color;
                    \\out vec2 uv;
                    \\out vec4 color;
                    \\void main() {
                    \\  vec2 pos = a_inst_pos_size.xy + a_pos * a_inst_pos_size.zw;
                    \\  gl_Position = u_projection * vec4(pos, 0.0, 1.0);
                    \\  uv = a_pos;
                    \\  color = a_inst_color;
                    \\}
                ,
            };
            desc.fragment_func = .{
                .source = 
                    \\#version 300 es
                    \\precision mediump float;
                    \\uniform sampler2D u_tex;
                    \\in vec2 uv;
                    \\in vec4 color;
                    \\out vec4 frag_color;
                    \\void main() {
                    \\  frag_color = texture(u_tex, uv) * color;
                    \\}
                ,
            };
        },
        else => {},
    }
    desc.uniform_blocks[0].stage = .VERTEX;
    desc.uniform_blocks[0].size = 64;
    desc.uniform_blocks[0].layout = .STD140;
    desc.images[0] = .{ .stage = .FRAGMENT, .image_type = ._2D };
    desc.samplers[0] = .{ .stage = .FRAGMENT, .sampler_type = .FILTERING };
    desc.image_sampler_pairs[0] = .{ .stage = .FRAGMENT, .glsl_name = "u_tex", .image_slot = 0, .sampler_slot = 0 };
    return desc;
}