// Auto-generated shader module for sprite rendering
// In production, this would be generated by sokol-shdc from sprite_shader.glsl
const sg = @import("sokol").gfx;

pub const ATTR_sprite_vs_a_pos = 0;
pub const ATTR_sprite_vs_a_inst_pos_size = 1;
pub const ATTR_sprite_vs_a_inst_color = 2;

pub const SLOT_u_tex = 0;
pub const SLOT_u_smp = 0;
pub const SLOT_vs_params = 0;

pub const VsParams = extern struct {
    u_projection: [16]f32,
};

pub fn spriteShaderDesc(backend: sg.Backend) sg.ShaderDesc {
    var desc = sg.ShaderDesc{};
    desc.label = "sprite_shader";
    
    switch (backend) {
        .D3D11 => {
            desc.attrs[0] = .{ .sem_name = "TEXCOORD", .sem_index = 0 };
            desc.attrs[1] = .{ .sem_name = "TEXCOORD", .sem_index = 1 };
            desc.attrs[2] = .{ .sem_name = "TEXCOORD", .sem_index = 2 };
            
            desc.vs.source = 
                \\cbuffer vs_params : register(b0) {
                \\    float4x4 u_projection;
                \\};
                \\struct vs_in {
                \\    float2 a_pos : TEXCOORD0;
                \\    float4 a_inst_pos_size : TEXCOORD1;
                \\    float4 a_inst_color : TEXCOORD2;
                \\    uint inst_id : SV_InstanceID;
                \\};
                \\struct vs_out {
                \\    float2 uv : TEXCOORD0;
                \\    float4 color : TEXCOORD1;
                \\    float4 pos : SV_Position;
                \\};
                \\vs_out main(vs_in inp) {
                \\    vs_out outp;
                \\    float2 pos = inp.a_inst_pos_size.xy + inp.a_pos * inp.a_inst_pos_size.zw;
                \\    outp.pos = mul(u_projection, float4(pos, 0.0, 1.0));
                \\    outp.uv = inp.a_pos;
                \\    outp.color = inp.a_inst_color;
                \\    return outp;
                \\}
            ;
            desc.vs.d3d11_target = "vs_5_0";
            desc.vs.entry = "main";
            
            desc.fs.source =
                \\Texture2D<float4> u_tex : register(t0);
                \\sampler u_smp : register(s0);
                \\
                \\float4 main(float2 uv : TEXCOORD0, float4 color : TEXCOORD1) : SV_Target0 {
                \\    return u_tex.Sample(u_smp, uv) * color;
                \\}
            ;
            desc.fs.d3d11_target = "ps_5_0";
            desc.fs.entry = "main";
        },
        .GLCORE => {
            desc.attrs[0] = .{ .name = "a_pos" };
            desc.attrs[1] = .{ .name = "a_inst_pos_size" };
            desc.attrs[2] = .{ .name = "a_inst_color" };
            
            desc.vs.source =
                \\#version 330
                \\uniform mat4 u_projection;
                \\layout(location=0) in vec2 a_pos;
                \\layout(location=1) in vec4 a_inst_pos_size;
                \\layout(location=2) in vec4 a_inst_color;
                \\out vec2 uv;
                \\out vec4 color;
                \\void main() {
                \\    vec2 pos = a_inst_pos_size.xy + a_pos * a_inst_pos_size.zw;
                \\    gl_Position = u_projection * vec4(pos, 0.0, 1.0);
                \\    uv = a_pos;
                \\    color = a_inst_color;
                \\}
            ;
            
            desc.fs.source =
                \\#version 330
                \\uniform sampler2D u_tex;
                \\in vec2 uv;
                \\in vec4 color;
                \\out vec4 frag_color;
                \\void main() {
                \\    frag_color = texture(u_tex, uv) * color;
                \\}
            ;
        },
        else => {},
    }
    
    // Common setup for all backends
    desc.vs.uniform_blocks[0].size = @sizeOf(VsParams);
    desc.vs.uniform_blocks[0].layout = .STD140;
    
    desc.fs.images[0] = .{ .used = true };
    desc.fs.samplers[0] = .{ .used = true };
    desc.fs.image_sampler_pairs[0] = .{ .used = true, .image_slot = 0, .sampler_slot = 0 };
    
    return desc;
}